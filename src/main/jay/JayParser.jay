%{
package org.autoimpl.parser;

import java.io.IOException;
import java.io.Reader;
import java.util.HashMap;

import org.autoimpl.ErrorLogger;
import org.autoimpl.cst.Specification;
import org.autoimpl.parser.jay.Input;
import org.autoimpl.parser.jay.SyntaxError;

public class JayParser {

    private Input input;
    private Specification specification;
    private boolean failed;
    private ErrorLogger errorLogger;
    
    public JayParser(ErrorLogger errorLogger)
    {
        this.errorLogger = errorLogger;
    }
%}

%token IDENTIFIER
%token SPECIFICATION
%token END
%token EOL 10

%start grammar

%%

eols:
	| EOL eols

grammar:
    eols SPECIFICATION IDENTIFIER { specification.setName((Identifier)$3); } EOL END
  

%%
    private static boolean contains(int[] tokens, int expected) {
        for (int token : tokens)
            if (token == expected)
                return true;
        return false;
    }

	private void yyerror(int[] expected) {
		failed = true;
		errorLogger.logError(new Position(input.row(), input.column()),
				"missing " + whatIsMissing(expected));
	}

	private String whatIsMissing(int[] expected) {
		if (contains(expected, SPECIFICATION))
			return "'specification'";
		if (contains(expected, END))
			return "'end'";
		return "specification name";
	}
	
    public Specification parseFile(Reader reader) {
        this.specification = new Specification();
    	try {
	        HashMap<String, Integer> keywords = new HashMap<String, Integer>();
	        keywords.put("specification", SPECIFICATION);
	        keywords.put("end", END);
	        HashMap<Character, Integer> punctuation = new HashMap<Character, Integer>();
	        this.input = new Scanner(reader, IDENTIFIER, keywords, punctuation);
	        yyparse(input);
	    } catch (SyntaxError e) {
	    } catch (IOException e) {
		}
        return failed ? null : this.specification;
    }
}